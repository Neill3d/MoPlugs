//////////////////////////////////////////////////////////////////////////////////////////////////
//
// file: Particles.glslfx
//
//	Author Sergey Solokhin (Neill3d)
//
// GLSL shaders for Particles System
//
//	GitHub page - https://github.com/Neill3d/MoPlugs
//	Licensed under BSD 3-Clause - https://github.com/Neill3d/MoPlugs/blob/master/LICENSE
//
///////////////////////////////////////////////////////////////////////////////////////////////////


#extension GL_ARB_separate_shader_objects : enable


ConstantBuffer global evaluateBlock
{
	uniform mat4					gTM;			// emitter transform
	uniform mat4					gRotationTM;	// only rotation
	uniform mat4					gNormalTM;
	uniform	mat4					gTextureTM;		// transform matrix for a texture when inherit colors from emitter surface

	uniform vec4					gDirection;		// vec3 - direction, 4th - use normals as dir or not
	
	uniform float					gDirSpreadHor;	// spread direction vector in horizontal plane
	uniform float					gDirSpreadVer;	// spread in vertical plane
	uniform float					gEmitSpeed;
	uniform float					gSpeedSpread;
	
	//uniform vec4					gDirRandom;
	//uniform vec4					gVelocity;		// start particle velocity
	//uniform vec4					gVelRandom;		// randomize start velocity
	uniform vec4					gEmitterVelocity; // use this velocity to inherit emitter speed
	//uniform vec4					gEmitterPivot;
	//uniform vec4					gAngularVelocity;	// rotation around pivot of the emitter

	//uniform mat4					gEmitterDeltaTM;

	uniform vec4					gDynamic;		// 1st - mass, 2nd - damping
	uniform vec4					gGravity;		// vec3 - gravity direction XYZ, 4-th component - use or not to use gravity
	uniform vec4					gFlags;			// 1st - useForces, 2nd - useCollisions, 3rd - emitter type(0.0-vertices, 1.0-volume)
	uniform vec4					gTurbulence;
	uniform vec4					gFloor;			// 1st - use/not use, 2nd - friction, 3rd - Y level
	uniform	vec4					gMin;			// local min
	uniform	vec4					gMax;			// local max

	uniform int						gPositionCount;	// number of position and normal vertices (emitter positions)
	uniform	int						gNumCollisions;
	uniform	int						gNumForces;
	uniform int						gUseEmitterTexture;	
	
	uniform float 					gLauncherLifetime;                                                    
	uniform float 					gShellLifetime;  
	uniform float					gShellLifetimeVariation;	// a percent of randomization                                                     
	uniform float 					gSecondaryShellLifetime;  

	uniform int						gUseSizeAttenuation;
	uniform int						gUseColorAttenuation;
	uniform float					gSizeVariation;
	uniform float					gColorVariation;	
	
	uniform	float					gSize;
	uniform	float					gInheritEmitterColor;
	uniform	float					gUseEmitterMask;
	uniform float					gSkipZeroAlpha;
	
	uniform	vec4					gEmitColor;
}

/////////////////////////////////////////////////////////// render block

ConstantBuffer global renderBlock
{
	uniform		mat4			gMV;
	uniform		mat4			gVP;
	
	uniform		vec4			gCameraPos;
	
	uniform		vec4			gColor;
	
	uniform 	float			gBillboardSize;
	uniform		float			gUseSizeCurve;
	uniform		float			gUseColorCurve;
	uniform		float			gTransparencyFactor;
	
	uniform		float			gMinPointScale;
	uniform		float			gMaxPointScale;
	uniform		float			gPointScaleDistance;
	uniform		float			gRenderTemp2;
}

//////////////////////////////////////////////////////////// terrainBlock
ConstantBuffer global terrainBlock
{
	uniform 	mat4 			gTerrainVP;       

	uniform 	vec4 			gTerrainOffset;
	uniform 	vec4 			gTerrainScale;
	
	//uniform mat4 gVP;       
	//uniform 	uvec2 			gTerrainColorAddress;  
	uniform 	float 			gTerrainFarPlane;
}

///////////////////////////////////////////////////////////////
//

uniform		float	gDeltaTimeMillis;
uniform		float	gTime;

uniform		mat4	gTerrainModelTM;

//////////////////////////////////////////////////////////

RasterizationState rasterStateFill
{
    LINE_WIDTH = 1;
    POLYGON_MODE={FRONT_AND_BACK, FILL};
}
RasterizationState rasterStateWire
{
    LINE_WIDTH = 2;
    POLYGON_MODE={FRONT_AND_BACK, LINE};
}
DepthStencilState dstStateFloor
{
    DEPTH_TEST = true;
    DEPTH_WRITEMASK = true;
    DEPTH_FUNC = LEQUAL;
}
//////////////////////////////////////////////////////////////
// GLSL Globals : meaning that all the GLSL domains (vertex, fragments etc.) will have a copy
// of these data
//
GLSLShader 
{
    #version 430 compatibility
	#extension GL_NV_shader_buffer_load : enable
	#extension GL_NV_shader_atomic_float : enable
	#extension GL_ARB_shader_storage_buffer_object : require
	#extension GL_ARB_shader_draw_parameters : require
	#extension GL_ARB_gpu_shader5 : enable
	#extension GL_ARB_enhanced_layouts : enable
	
	// this extensions don't exist on quadro 4000
	#extension GL_ARB_bindless_texture : enable
	#extension GL_ARB_gpu_shader_int64 : enable
	
	//
	#define PARTICLE_TYPE_LAUNCHER 0.0f                                                 
	#define PARTICLE_TYPE_SHELL 1.0f                                                    
	#define PARTICLE_TYPE_SECONDARY_SHELL 2.0f   

	#define		USE_TERRAIN			gTerrain.w
	#define		TERRAIN_FRICTION	gTerrain.x

	#define		DIRECTION			gDirection.xyz
	#define		USE_NORMALS_AS_DIR	gDirection.w

	#define		MASS				gDynamic.x
	#define		DAMPING				gDynamic.y

	#define		USE_GRAVITY			gGravity.w
	#define		GRAVITY				gGravity.xyz

	#define 	USE_TURBULENCE		gTurbulence.w
	#define		NOISE_FREQ			gTurbulence.x
	#define		NOISE_SPEED			gTurbulence.y
	#define		NOISE_AMP			gTurbulence.z

	#define		USE_FORCES			gFlags.x
	#define		USE_COLLISIONS		gFlags.y
	#define		EMITTER_TYPE		gFlags.z

	#define		EMITTER_TYPE_VERTICES	0.0
	#define		EMITTER_TYPE_VOLUME		1.0
	#define		EMITTER_TYPE_SURFACE	2.0
	
	#define		FORCE_WIND				1.0
	#define		FORCE_DRAG				2.0
	#define		FORCE_MOTOR				3.0

	#define		USE_FLOOR			gFloor.w
	#define		FLOOR_FRICTION		gFloor.y
	#define		FLOOR_LEVEL			gFloor.z
	
	// emitter surface
	struct TTriangle
	{
		vec4	p[3];
		//vec4	p1;
		//vec4	p2;

		vec4	n;

		vec2	uv[3];
		//vec2	uv0;
		//vec2	uv1;
		//vec2	uv2;

		vec2	temp;	// to align type
	};
	
	const float PiPi = 6.2831853;
	const float PI = 3.14159265;
	const float PI_2 = 1.57079632;
	const float PI_4 = 0.785398163;
	
	const vec2 randN1 = vec2(0.14, -0.07);
	const vec2 randN2 = vec2(0.77, 1.01);
	const vec2 randN3 = vec2(-0.38, 0.15);
	
	// DONE: can be overrided in different techniques, depends on user choise
	highp float rand(vec2 co);
	void GetRandomDir(in vec4 inDir, in vec2 dirRnd, out vec4 dir);
	float GetRandomSpeed(float randomF);
	
	// choose a shader between volume, vertex and surface generation
	void GetEmitPos(in vec2 randN, out vec4 pos, out int vertIndex, out vec3 bary);
	void GetEmitDir(in int vertIndex, in float randomF, out vec4 vel);
	void GetEmitColor(in vec4 pos, in int vertIndex, in vec3 bary, out vec4 color);
	
	// choose between launcher pre-defined or dynamic generation
	void GenerateNewParticle(in float randomF, inout vec4 pos, inout vec4 vel, inout vec4 rot, inout vec4 rotVel, inout vec4 color);
}

//#include "Particles_generation.glslfxh"

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions that we will use to output fragments in various ways
//

////////////////////////////////////////////////////////////////////
/// Evaluate things
////////////////////////////////////////////////////////////////////

namespace Evaluate
{
	
	// prototype is in globals.glslfxh
	
	GLSLShader	RandomCode
	{
		highp float rand(vec2 co)
		{
			highp float a = 12.9898;
			highp float b = 78.233;
			highp float c = 43758.5453;
			highp float dt= dot(co.xy ,vec2(a,b));
			highp float sn= mod(dt,3.14);
			return fract(sin(sn) * c);
		}
		
		//
		// out float r, out float theta, out float phi
		void ConvertUnitVectorToSpherical(const vec4 v, out vec3 sv)
		{
			sv.x = sqrt(v.x*v.x + v.y*v.y + v.z*v.z); // r
			sv.y = atan( v.y,  v.x ); // theta
			sv.z = atan( sqrt(v.x*v.x+v.y*v.y), v.z ); // phi
		}

		// const float r, const float theta, const float phi
		void ConvertSphericalToUnitVector(vec3 sv, out vec4 v)
		{
			v.x = sv.x * cos(sv.y) * sin(sv.z);
			v.y = sv.x * sin(sv.y) * sin(sv.z);
			v.z = sv.x * cos(sv.z);
			v.w = 1.0;
		}

		void GetRandomDir(in vec4 inDir, in vec2 dirRnd, out vec4 dir)                                                   
		{
			//float r, theta, phi;
			vec3 sv;

			ConvertUnitVectorToSpherical(inDir, sv);

			sv.y += dirRnd.x * PI;
			sv.z += dirRnd.y * PiPi;
			
			ConvertSphericalToUnitVector(sv, dir);
		} 
		
		float GetRandomSpeed(float randomF)
		{
			float rnd = 2.0*gEmitSpeed*rand(vec2(randomF, 1.0))-gEmitSpeed;
			return (gEmitSpeed - rnd * gSpeedSpread);
		}
	}
	
	// use pre-defined launcher data
	GLSLShader PreGenerated
	{
		void GenerateNewParticle(in float randomF, inout vec4 pos, inout vec4 vel, inout vec4 rot, inout vec4 rotVel, inout vec4 color)
		{
			vec4 newpos = gTM * vec4(pos.xyz, 1.0);
			pos.xyz = newpos.xyz;
			
			rot.w = 0.0; // Age1 = 0.0;                  
			// new lifetime
			vel = gRotationTM * vec4(vel.xyz, 1.0);
			vel.xyz = vel.xyz + gEmitterVelocity.w * gEmitterVelocity.xyz; 
			//vel = gEmitterDeltaTM * vel;	// inherit emitter movement
			vel.w = gShellLifetime + (rand(vec2(randomF,0.487)) * 2.0 - 1.0) * gShellLifetime * gShellLifetimeVariation;
			rotVel.w = 1.0; // Index1 = 1.0; // rand(vec2(randomF, 1.0));
		}
	}
	
	// dynamic new shell generation in a shader code
	
	GLSLShader EmitFromVolume
	{
		//
		//
		void GetEmitPos(in vec2 randN, out vec4 pos, out int vertIndex, out vec3 bary)
		{
			vec4 lMax = gMax;
			vec4 lMin = gMin;
					
			// if inherit emitter velocity, put particle on some random position during the way
			/*
			vec4 delta = gEmitterVelocity * gEmitterVelocity.w;
			delta = delta * rand(randN);
			lMax = lMax - delta;
			lMin = lMin - delta;
			*/
			
			vec3 rnd = vec3( rand(randN+randN1), rand(randN+randN2), rand(randN+randN3) );
			
			
			pos.x = (lMax.x - lMin.x) * rnd.x + lMin.x;
			pos.y = (lMax.y - lMin.y) * rnd.y + lMin.y;
			pos.z = (lMax.z - lMin.z) * rnd.z + lMin.z;
			pos.w = 1.0;
			
			//pos = gTM * pos;
		}
		
		void GetEmitDir(in int vertIndex, in float randomF, out vec4 vel)
		{
			GetRandomDir(gDirection, vec2(gDirSpreadHor * rand(vec2(randomF, 2.03)), gDirSpreadVer * rand(vec2(randomF, 0.789))), vel);
		}
		
		void GetEmitColor(in vec4 pos, in int vertIndex, in vec3 bary, out vec4 color)
		{
			vec4 lMax = gMax;
			vec4 lMin = gMin;
	
			color.x = (pos.x - lMin.x) / (lMax.x - lMin.x);
			color.y = (pos.y - lMin.y) / (lMax.y - lMin.y);
			color.z = (pos.z - lMin.z) / (lMax.z - lMin.z);
			color.w = 1.0;
		}
	}
	
	/////////////////////////////////////
	//
	GLSLShader EmitFromVertices
	{
		uniform 	TTriangle 	*gEmitMesh;
		layout(binding=0) 		uniform		sampler2D	gEmitTexture;	// particles will inherit texture texel under the surface point
		layout(binding=1)		uniform		sampler2D	gEmitMask;	// mask out particles emitting (model UV-based mask)
		
		void GetEmitPos(in vec2 randN, out vec4 out_pos, out int vertIndex, out vec3 bary)
		{
			
			TTriangle	*surfaceData = gEmitMesh;
			
			float rnd = rand(randN) * gPositionCount;
			int triIndex = (int) rnd;

			rnd = clamp(2.0 * rand(randN+randN1), 0.0, 1.0);
			int rndIndex = int(rnd);
			
			vec4 lpos = vec4(0.0);
			
			lpos = surfaceData[triIndex].p[rndIndex];
			vertIndex = triIndex * 3 + rndIndex;
			
			//out_pos = gTM * vec4(lpos.xyz, 1.0);
			out_pos = vec4(lpos.xyz, 1.0);
		}

		void GetEmitDir(in int vertIndex, in float randomF, out vec4 vel) 
		{
			int triIndex = vertIndex / 3;
			TTriangle	*surfaceData = gEmitMesh;
			
			vec4 indir = surfaceData[triIndex].n;

			// DONE: randomize normal vector !!
			GetRandomDir(indir, vec2(gDirSpreadHor * rand(vec2(randomF, 2.03)), gDirSpreadVer * rand(vec2(randomF, 0.789))), vel);
			
		}   

		void GetEmitColor(in vec4 pos, in int vertIndex, in vec3 bary, out vec4 color)
		{
			int triIndex = vertIndex / 3;
			TTriangle	*surfaceData = gEmitMesh;
			
			// read from texture image

			vec2 uv0 = surfaceData[triIndex].uv[0];
			vec2 uv1 = surfaceData[triIndex].uv[1];
			vec2 uv2 = surfaceData[triIndex].uv[2];

			uv0 *= bary.x;
			uv1 *= bary.y;
			uv2 *= bary.z;

			vec2 uv = uv0 + uv1 + uv2;

			// color
			if (gUseEmitterTexture > 0)
			{
				vec4 texcoords = gTextureTM * vec4(uv.x, uv.y, 0.0, 1.0);
				color = texture(gEmitTexture, texcoords.st);
			}
			else
			{
				color = surfaceData[triIndex].n;
			}
			// mask
			if (gUseEmitterMask > 0)
			{
				color.a = texture(gEmitMask, uv).a;
			}
		}
	}
	
	////////////////////////////////////////
	//
	GLSLShader EmitFromSurface
	{
		//layout(location=6) flat in TTriangle	*inMesh[];
		uniform 	TTriangle 	*gEmitMesh;
		layout(binding=0) 		uniform		sampler2D	gEmitTexture;	// particles will inherit texture texel under the surface point
		layout(binding=1)		uniform		sampler2D	gEmitMask;	// mask out particles emitting (model UV-based mask)
		
		void GetEmitPos(in vec2 randN, out vec4 pos, out int vertIndex, out vec3 bary)
		{
			
			TTriangle	*surfaceData = gEmitMesh;

			float rnd = rand(randN) * gPositionCount;
			int triIndex = (int) rnd;

			// barycentric coords
			float rnd1 = rand(randN+randN1);
			float rnd2 = rand(randN+randN2);

			bary.x = 1.0 - sqrt(rnd1);
			bary.y = sqrt(rnd1) * (1.0 - rnd2);
			bary.z = sqrt(rnd1) * rnd2; 

			vec4 p0 = surfaceData[triIndex].p[0];
			vec4 p1 = surfaceData[triIndex].p[1];
			vec4 p2 = surfaceData[triIndex].p[2];

			p0 *= bary.x;
			p1 *= bary.y;
			p2 *= bary.z;

			vec4 P = p0 + p1 + p2;
			vertIndex = triIndex * 3;

			//pos = gTM * vec4(P.xyz, 1.0);
			pos = vec4(P.xyz, 1.0);
			// TODO: extrusion dist is not used !
		}
		
		void GetEmitDir(in int vertIndex, in float randomF, out vec4 vel)
		{
			int triIndex = vertIndex / 3;
			TTriangle	*surfaceData = gEmitMesh;
			
			vec4 indir = surfaceData[triIndex].n;

			// DONE: randomize normal vector !!
			GetRandomDir(indir, vec2(gDirSpreadHor * rand(vec2(randomF, 2.03)), gDirSpreadVer * rand(vec2(randomF, 0.789))), vel);
			//vel = indir;
		}
		
		void GetEmitColor(in vec4 pos, in int vertIndex, in vec3 bary, out vec4 color)
		{
			int triIndex = vertIndex / 3;
			TTriangle	*surfaceData = gEmitMesh;
			
			// read from texture image

			vec2 uv0 = surfaceData[triIndex].uv[0];
			vec2 uv1 = surfaceData[triIndex].uv[1];
			vec2 uv2 = surfaceData[triIndex].uv[2];

			uv0 *= bary.x;
			uv1 *= bary.y;
			uv2 *= bary.z;

			vec2 uv = uv0 + uv1 + uv2;

			// color
			if (gUseEmitterTexture > 0)
			{
				vec4 texcoords = gTextureTM * vec4(uv.x, uv.y, 0.0, 1.0);
				color = texture(gEmitTexture, texcoords.st);
			}
			else
			{
				color = surfaceData[triIndex].n;
			}
			// mask
			if (gUseEmitterMask > 0)
			{
				color.a = texture(gEmitMask, uv).a;
			}
		}
	}
	
	//////////////////////////////////////////////////////
	//
	GLSLShader DynamicGeneration
	{
		
		void GetRandomColor(in vec4 incolor, in float randomF, in float variation, out vec4 outcolor)
		{
			vec4 varcolor = vec4(rand(vec2(randomF, 3.07)), rand(vec2(randomF, -4.04)), rand(vec2(randomF, 1.01)), 0.0);
			varcolor = varcolor * vec4(2.0 * variation);
			varcolor = varcolor - vec4(variation, variation, variation, 0.0);
			
			outcolor = clamp(incolor + varcolor, vec4(0.0), vec4(1.0) );
		}
		
		float GetRandomSize(in float randomF)
		{
			float f = 2.0 * gSize * gSizeVariation * rand(vec2(randomF, 10.10));
			return gSize + (f - gSize * gSizeVariation);
		}
		
		void GenerateNewParticle(in float randomF, inout vec4 pos, inout vec4 vel, inout vec4 rot, inout vec4 rotVel, inout vec4 color)
		{
			vec4 newPos = vec4(0.0);
			vec4 Dir = vec4(0.0);
			if (USE_NORMALS_AS_DIR == 0.0)
				//Dir = gDirection;
				GetRandomDir(gDirection, vec2(gDirSpreadHor * rand(vec2(randomF, 2.03)), gDirSpreadVer * rand(vec2(randomF, 0.789))), Dir);
			
			color = vec4(1.0, 1.0, 1.0, 1.0);
			
			int vertIndex = 0;
			vec3 baryCoords;
			
			GetEmitPos(vec2(randomF, 0.487), newPos, vertIndex, baryCoords);
			
			if (USE_NORMALS_AS_DIR > 0.0)
				GetEmitDir(vertIndex, randomF, Dir);
			
			if (gInheritEmitterColor > 0)
				GetEmitColor(newPos, vertIndex, baryCoords, color);
			else
				GetRandomColor(gEmitColor, randomF, gColorVariation, color);
			
			float newSize = GetRandomSize(randomF);
			//newPos = inverse(gEmitterDeltaTM) * vec4(newPos.xyz, 1.0);
			newPos = gTM * vec4(newPos.xyz, 1.0);
			pos = vec4(newPos.xyz - gEmitterVelocity.w * gEmitterVelocity.xyz, newSize);
			//pos = vec4(newPos.xyz, newSize);

			Dir = gRotationTM * vec4( normalize(Dir.xyz), 1.0 );
			Dir.xyz = GetRandomSpeed(randomF) * Dir.xyz;
			//vel = gEmitterDeltaTM * vec4(Dir.xyz, 1.0);
			vel.xyz = Dir.xyz + gEmitterVelocity.w * gEmitterVelocity.xyz;
			rot = vec4(0.0); // Age1 = 0.0;                  
			
			vel.w = gShellLifetime + (rand(vec2(randomF,0.487)) * 2.0 - 1.0) * gShellLifetime * gShellLifetimeVariation;
			rotVel = vec4(0.0, 0.0, 0.0, 1.0); // Index1 = 1.0; // rand(vec2(randomF, 1.0));
		}
	}
	
    ////////////////////////////////////////////////////////////////////
    /// EVALUATE's VERTEX PROGRAM ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////
    GLSLShader VS_EMIT
    {
		//layout (location = 0) in vec4 OldPosition;	// w - Type                                                
		layout (location = 0) in vec4 Position;                                             
		layout (location = 1) in vec4 Velocity;
		layout (location = 2) in vec4 Color;
		layout (location = 3) in vec4 Rot; // float Age;       
	
		                                                                    
		layout(location=0) out vec4 Position0;                                                                 
		layout(location=1) out vec4 Velocity0;                       
		layout(location=2) out vec4 Color0;                                         
		layout(location=3) out vec4 Rot0; // float Age0;                                                                     
		layout(location=4) out vec4 RotVel0; // float Index0;
		
		
		//////////////////////////////////////////////////////////
		//
		void main()                                                                         
		{                                                                                        
			Position0 = Position;                                                           
			Velocity0 = Velocity;                                                           
			Color0 = Color;
			Rot0 = Rot;  
			RotVel0 = vec4(0.0, 0.0, 0.0, 10.0); // Index0 = 10.0;
		}
    }
	
    ////////////////////////////////////////////////////////////////////
    /// WIRE's FRAGMENT PROGRAM ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////
    GLSLShader GS_EMIT
    {
		precision highp int;

		layout(points) in;                                                                  
		layout(points, max_vertices = 2) out;                                                      
                                                                 
		layout(location=0) in vec4 Position0[];                                                                
		layout(location=1) in vec4 Velocity0[];                                                                
		layout(location=2) in vec4 Color0[];   
		layout(location=3) in vec4 Rot0[]; // float Age0[];  
		layout(location=4) in vec4 RotVel0[]; // float Index0[];                                                                  
		 

		// everything in this block goes to buffer 0
        layout (xfb_buffer = 0, xfb_stride = 80) out block1 {
            //layout (xfb_offset = 0)  vec4 OldPosition1; // a goes to byte offset 0 of buffer 0
            layout (xfb_offset = 0) vec4 Position1; // b goes to offset 16 of buffer 0
			layout (xfb_offset = 16) vec4 Velocity1; // b goes to offset 16 of buffer 0
			layout (xfb_offset = 32) vec4 Color1; // b goes to offset 16 of buffer 0
			layout (xfb_offset = 48) vec4 Rot1; // float Age1; // b goes to offset 16 of buffer 0
			layout (xfb_offset = 64) vec4 RotVel1; // float Index1; // b goes to offset 16 of buffer 0
        };
		
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// MAIN
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		void main()                                                                         
		{                        
			mat4 ltm = gTM;
		
			float Age = Rot0[0].w; // + gDeltaTimeMillis;                                         
			float randomF = gTime + gl_PrimitiveIDIn;
			
			float lifetime = Velocity0[0].w;
			
			if (gFlags.x > 0.0 && lifetime < 0.0 && Age >= -lifetime) {
				
				vec4 newPosition = Position0[0];
				vec4 newVelocity = Velocity0[0];
				vec4 newRotation = Rot0[0];
				vec4 newRotVel = RotVel0[0];
				vec4 newColor = Color0[0];
				
				// launcher has a negative size value
				newPosition.w = -1.0 * newPosition.w;
				
				GenerateNewParticle(randomF, newPosition, newVelocity, newRotation, newRotVel, newColor);
				
				if (0.0 == gSkipZeroAlpha || newColor.a > 0.5)
				{
					Position1 = newPosition;
					Velocity1 = newVelocity; 	
					Rot1 = newRotation;
					RotVel1 = newRotVel;
					Color1 = newColor;
				
					EmitVertex();                                                           
					EndPrimitive();                                                         
					// reset launcher age to next time (one launch per second)
					Age = -1.0f * lifetime - 1.0;  
				}
			}
			
			//
			if (lifetime != 0.0)
			{
				// keep particle (launcher or shell)
				
				Position1 = Position0[0];
				//Position1.xyz = vec3(-9999.0, -9999.0, -9999.0);
				Velocity1 = Velocity0[0]; 	
				Rot1 = vec4(Rot0[0].xyz, Age);      
				RotVel1 = RotVel0[0];
				Color1 = Color0[0];
				EmitVertex();                                                               
				EndPrimitive();   
			}
		}
    }
	
}


namespace Render
{
	GLSLShader VS_Points
	{
		
		layout (location = 0) in vec4 Position;                                        
		layout (location = 1) in vec4 Velocity; // .w - Total Lifetime
		layout (location = 2) in vec4 Color;
		layout (location = 3) in vec4 Rotation; // .w - Age
		
		out float 	life;
		out vec4	pcolor;
		out vec3	wv;
		
		out gl_PerVertex {
            vec4 gl_Position;		// 16 bytes
			float gl_PointSize;
        };

		void main()                                                                         
		{           
			float size = Position.w; // gBillboardSize;
		
			// Calculate point scale based on distance from the viewer
			// to compensate for the fact that gl_PointSize is the point
			// size in rasterized points / pixels.
			float cameraDist = distance(Position.xyz, gCameraPos.xyz);
			float pointScale = 1.0 - (cameraDist / gPointScaleDistance);
			pointScale = max(pointScale, gMinPointScale);
			pointScale = min(pointScale, gMaxPointScale);
			
			vec4 vPosition = gMV * vec4(Position.xyz, 1.0);
			
			gl_Position = gVP * vPosition;  
			gl_PointSize = size * pointScale;

			// float normLife = Age / lifetime;
			life = clamp(Rotation.w / (Velocity.w+0.001), 0.0, 1.0);

			pcolor = Color;
			
			// clip the launchers
			if (size < 0.0)
				gl_Position.w = 0.0;
			
			wv = vPosition.xyz;
		} 
	}
	
	
	GLSLShader FS_Points
	{
		//uniform sampler2D gColorMap;                                                        
		in float life;
		in vec4 	pcolor;
		in vec3		wv;
		//out vec4 FragColor;                                                                 

		layout(location=0) out vec4 	outColor;
		layout(location=1) out vec4		outNormal;	// output a view space normal
		layout(location=2) out vec4		outMask;
		layout(location=3) out vec4		outPosition;
		
		layout(binding=6) uniform sampler1D	ColorCurve;

		void main()                                                                         
		{       
			//if (life >= 0.99 || life == 0.0) discard;

			// color should be taken from the particles (can be part of simulation)
			vec4 color = pcolor;
			
			if (gUseColorCurve > 0.0)
			{
				color = color * texture(ColorCurve, life);
			}
			
			color.w *= gTransparencyFactor;
			outColor = color;
			
			outNormal = vec4(normalize(wv), 1.0); // vec4(0.0, 1.0, 0.0, 0.0); // vec4( normalize(inNw), albedo.w );
			//outNormal = normalize(inNw);
			
			outPosition = vec4(wv, 1.0); // fMesh->lightmap);
			outMask = vec4(0.0); // theShader->mask;
		}
	}
}

// DONE: convert glsl 330 into glsl 420 syntax
namespace Terrain
{
	GLSLShader VS_Prepare
	{
		layout(location = 0) in vec4	Position;
		out float Depth;

		out gl_PerVertex {
            vec4 gl_Position;		// 16 bytes
        };
		
		void main()                                                                         
		{                           
			vec4 pos = gTerrainModelTM * vec4(Position.xyz, 1.0);
			float temp = pos.z;
			pos.z = pos.y;
			pos.y = -temp;
			
			Depth = pos.z;
			
			gl_Position = gTerrainVP * pos;
		} 
	}
 
	GLSLShader FS_Prepare
	{
		
		in float Depth;                                                               
		out vec4 FragColor;
		/*
		vec4 packFloatToVec4i(const float value)
		{
		  const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
		  const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
		  vec4 res = fract(value * bitSh);
		  res -= res.xxyz * bitMsk;
		  return res;
		}
		*/
		void main()                                                                         
		{         
			//gl_FragColor = packFloatToVec4i(Depth);
			FragColor = vec4(Depth, Depth, Depth, 1.0);
		}
	}
	
	GLSLShader VS_Render
	{
		layout (location = 0) in vec3 Position; 
		out vec2 uv;                                            

		out gl_PerVertex {
            vec4 gl_Position;		// 16 bytes
        };
		
		void main()                                                                         
		{                                                                                   
			gl_Position = gTerrainVP * vec4(Position.xyz, 1.0);  
			
			uv = (Position.xz - gTerrainOffset.xz) / gTerrainScale.xz;
		} 
	}

	GLSLShader FS_Render
	{
		layout(binding=0) uniform		sampler2D	gTerrainColorSampler;
		
		in vec2 uv;
		out vec4 FragColor;                                                                 

		float unpackFloatFromVec4i(const vec4 value)
		{
		  const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
		  return(dot(value, bitSh));
		}

		void main()                                                                         
		{
			float Depth = texture(gTerrainColorSampler, uv).s;
			
			vec4 color = vec4(Depth, Depth, Depth, 1.0);	
			FragColor = color;
		}
	}
	
	// only if bindless textures supported
	GLSLShader FS_RenderBindless
	{
		uniform 	uint64_t 		gTerrainColorAddress;  
		
		in vec2 uv;
		out vec4 FragColor;                                                                 

		float unpackFloatFromVec4i(const vec4 value)
		{
		  const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
		  return(dot(value, bitSh));
		}

		void main()                                                                         
		{
			sampler2D sm = sampler2D(gTerrainColorAddress);
			//float Depth = unpackFloatFromVec4i( texture(sm, uv) );
			float Depth = texture(sm, uv).s;
			FragColor = vec4(Depth, Depth, Depth, 1.0);
			//FragColor = vec4(Depth.x, Depth.y, 0.0, 1.0);
		}
	}
}

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
// Material Technique
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

Technique Init
{
    Pass init
    {
        PolygonOffset = {1.0,1.0};
        DEPTH_TEST = True;
        DEPTH_FUNC = LEQUAL;
        DEPTH_MASK = True;
    }
}

Technique volumeEmitter
{
	Pass p0
	{
		VertexProgram = Evaluate::VS_EMIT;
		GeometryProgram = {Evaluate::RandomCode, Evaluate::EmitFromVolume, Evaluate::DynamicGeneration, Evaluate::GS_EMIT};
	}
}

Technique verticesEmitter
{
	Pass p0
	{
		VertexProgram = Evaluate::VS_EMIT;
		GeometryProgram = {Evaluate::RandomCode, Evaluate::EmitFromVertices, Evaluate::DynamicGeneration, Evaluate::GS_EMIT};
	}
}

Technique surfaceEmitter
{
	Pass p0
	{
		VertexProgram = Evaluate::VS_EMIT;
		GeometryProgram = {Evaluate::RandomCode, Evaluate::EmitFromSurface, Evaluate::DynamicGeneration, Evaluate::GS_EMIT};
	}
}

Technique emitPreGenerated
{
	Pass p0
	{
		VertexProgram = Evaluate::VS_EMIT;
		GeometryProgram = {Evaluate::RandomCode, Evaluate::PreGenerated, Evaluate::GS_EMIT};
	}
}

Technique renderPoints
{
	Pass p0
	{
		VertexProgram = Render::VS_Points;
		FragmentProgram = Render::FS_Points;
	}
}

Technique terrainPrepare
{
	Pass p0
	{
		VertexProgram = Terrain::VS_Prepare;
		FragmentProgram = Terrain::FS_Prepare;
	}
}

Technique terrainPreview
{
	Pass p0
	{
		VertexProgram = Terrain::VS_Render;
		FragmentProgram = Terrain::FS_Render;
	}
}

Technique terrainPreviewBindless
{
	Pass p0
	{
		VertexProgram = Terrain::VS_Render;
		FragmentProgram = Terrain::FS_RenderBindless;
	}
}